#+title: Parsing markdown with functions
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: num:nil toc:nil author:nil

* Parsing a char

  #+ATTR_REVEAL: :frag (appear)
  We would like to parse the character ~a~.
  
** Design
   
   #+ATTR_REVEAL: :frag (appear)
   The parser of =a= is a function that, given an input string
   =s=:

   #+ATTR_REVEAL: :frag (appear)
   - succeds parsing a
   - or fails parsing a

** Implemenentation #1

   #+ATTR_REVEAL: :frag (appear)
   #+begin_src clojure :eval never

(defn parse-a [s]
  (if (= \a (first s))
    {:success ["a" (subs s 1)] }
    {:error s }))

   #+end_src

** Demo

#+BEGIN_NOTES
On the repl, try:
(parse-a "hello")
(parse-a "ahello")
#+END_NOTES

* Refactor

** Hide implementation

   #+ATTR_REVEAL: :frag (appear)
   #+BEGIN_SRC clojure :eval never

(defn- as-str
  "Ensures wathever is returned as string"
  [whatever]
  (cond (char? whatever) (str whatever)
        (empty? whatever) ""
        (string? whatever) whatever))

   #+END_SRC

   #+ATTR_REVEAL: :frag (appear)
   #+BEGIN_SRC clojure :eval never

(defn- success
  "Creates a success"
  [parsed nonparsed]
  {:success [(as-str parsed) (as-str nonparsed)]})

   #+END_SRC

   #+ATTR_REVEAL: :frag (appear)
   #+BEGIN_SRC clojure :eval never

(defn- fail
  "Creates a failure"
  [s]
  {:failure (as-str s)})
   
   #+END_SRC

** Implementation #2

   #+ATTR_REVEAL: :frag (appear)
   #+BEGIN_SRC clojure :eval never

(defn parse-a [s]
  (if (= \a (first s))
    (success \a (subs s 1))
    (fail s)))
   
   #+END_SRC



* Generalize

** 

   #+ATTR_REVEAL: :frag (appear)
   Now that we know how to parse the =a= character, we can generalize a bit.

** Parsing any character

   #+ATTR_REVEAL: :frag (appear)
   Given a character =c=, return a parser that parses =c=.

   #+ATTR_REVEAL: :frag (appear)
   #+BEGIN_SRC clojure :eval never

(defn parse-char
  "Returns a char parser"
  [c]
  (fn [s]
    (if (= c (first s))
      (success c (subs s 1))
      (fail s))))
   
   #+END_SRC

** Implementation #3 

   #+ATTR_REVEAL: :frag (appear)
   #+BEGIN_SRC clojure :eval never

(def parse-a (parse-char \a)) 
   
   #+END_SRC

* Paradigm shift


** 
  
   #+ATTR_REVEAL: :frag (appear)
   From:
   #+ATTR_REVEAL: :frag (appear)
  #+BEGIN_SRC clojure :eval never

(defn parse-a [s]
  (if (= \a (first s))
    {:success ["a" (subs s 1)] }
    {:error s }))

  #+END_SRC

   #+ATTR_REVEAL: :frag (appear)
  to

   #+ATTR_REVEAL: :frag (appear)
  #+BEGIN_SRC clojure :eval never
  
(def parse-a (parse-char \a)) 

  #+END_SRC

** Parsers

   #+ATTR_REVEAL: :frag (appear)
   Now *parsers* (a special kind of functions) are
   the *objects* we deal with (we use =def=, not =defn=).

** But we're not there yet.
   We have to climb another level.
* Next level
** 
   - We now want to parse either =a= or =b=.
   - We want a single parser that is capable of parsing any of
     the two.
** 
   #+BEGIN_SRC clojure :eval never

(defn parse-a-or-b [a b]
  (fn [s]
    (let [f (first s)]
      (if (or (= a f)
              (= b f))
        (success f (subs s 1))
        (fail s)))))
 
   #+END_SRC
** Works?
** Works? 
   Yes
** STOP! 
** Are you listening to me?
   #+ATTR_REVEAL: :frag (appear)
   - Parsers are the objects, not characters!
   - We have left those behind!

** Create helpers

   #+BEGIN_SRC clojure :eval never

(defn- get-nonparsed
  "Extracts next string to be parsed from a success"
  [suc]
  (let [[parsed nonparsed] (:success suc)]
    nonparsed))

(defn- get-parsed
  "Extracts parsed part from success"
  [suc]
  (let [[parsed nonparse] (:success suc)]
    parsed))
   
   #+END_SRC

* 

  
* End

